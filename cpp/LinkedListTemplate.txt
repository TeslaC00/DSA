#pragma once
#include <iostream>
#include <stdexcept>
#include <vector>
#include <utility>

template <typename T>
struct Node {
    T m_data;
    Node* m_next = nullptr;
    Node* m_prev = nullptr;

    Node(const T& value) : m_data(value) {}
};

template <typename T>
class LinkedList {
public:
    LinkedList() : m_size(0), m_head(nullptr) {}
    
    // Destructor
    ~LinkedList() {
        clear();
    }

    // Copy constructor
    LinkedList(const LinkedList& other) {
        for (Node<T>* current = other.m_head; current != nullptr; current = current->m_next) {
            insertLast(current->m_data);
        }
    }

    // Move constructor
    LinkedList(LinkedList&& other) noexcept : m_size(other.m_size), m_head(other.m_head) {
        other.m_size = 0;
        other.m_head = nullptr;
    }

    // Size and empty checks
    int size() const { return m_size; }
    bool isEmpty() const { return m_size == 0; }

    // Insert methods
    void insertFirst(const T& value) {
        Node<T>* newNode = new Node<T>(value);
        if (isEmpty()) {
            m_head = newNode;
            newNode->m_next = newNode;
            newNode->m_prev = newNode;
        } else {
            newNode->m_next = m_head;
            newNode->m_prev = m_head->m_prev;
            m_head->m_prev->m_next = newNode;
            m_head->m_prev = newNode;
            m_head = newNode;
        }
        m_size++;
    }

    void insertLast(const T& value) {
        Node<T>* newNode = new Node<T>(value);
        if (isEmpty()) {
            m_head = newNode;
            newNode->m_next = newNode;
            newNode->m_prev = newNode;
        } else {
            newNode->m_prev = m_head->m_prev;
            newNode->m_next = m_head;
            m_head->m_prev->m_next = newNode;
            m_head->m_prev = newNode;
        }
        m_size++;
    }

    // Accessors
    T getFirst() const {
        if (isEmpty()) throw std::out_of_range("List is empty");
        return m_head->m_data;
    }

    T getLast() const {
        if (isEmpty()) throw std::out_of_range("List is empty");
        return m_head->m_prev->m_data;
    }

    T getAt(int index) const {
        if (index < 0 || index >= m_size) throw std::out_of_range("Index out of range");
        Node<T>* current = m_head;
        for (int i = 0; i < index; i++) {
            current = current->m_next;
        }
        return current->m_data;
    }

    // Clear the list
    void clear() {
        while (!isEmpty()) {
            removeFirst();
        }
    }

    // Remove methods
    void removeFirst() {
        if (isEmpty()) return;
        if (m_size == 1) {
            delete m_head;
            m_head = nullptr;
        } else {
            Node<T>* toDelete = m_head;
            m_head->m_prev->m_next = m_head->m_next;
            m_head->m_next->m_prev = m_head->m_prev;
            m_head = m_head->m_next;
            delete toDelete;
        }
        m_size--;
    }

    void removeLast() {
        if (isEmpty()) return;
        if (m_size == 1) {
            removeFirst();
            return;
        }
        Node<T>* toDelete = m_head->m_prev;
        toDelete->m_prev->m_next = m_head;
        m_head->m_prev = toDelete->m_prev;
        delete toDelete;
        m_size--;
    }

    // Utility methods
    void print() const {
        if (isEmpty()) {
            std::cout << "List is empty\n";
            return;
        }
        Node<T>* current = m_head;
        do {
            std::cout << current->m_data << " <-> ";
            current = current->m_next;
        } while (current != m_head);
        std::cout << "HEAD\n";
    }

private:
    int m_size;
    Node<T>* m_head;
};
